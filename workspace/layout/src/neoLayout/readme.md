暂时存放在这里，开发完成后，合并到`NEO-UI-FRAME`中去.

## 为什么要写一个布局的类

因为原始的`grid-2d`的能力和我们整体的体系不契合（主要是元数据和布局设置能力），而我们又不想不断hack `grid-2d布局`导致其混乱，所以需要重新写一个布局的类。

除此之外，以下的功能介绍可以看到，我们要的太多，而`grid-2d`能给的太少

## 布局引擎（开发中）

neoui布局引擎，支持装载布局类型（此处仅指UI中用于描述位置、大小关系等纯UI渲染相关的对象），提供设计态的操作能力和渲染态的纯渲染。

布局引擎支持遵守数据规范的任何布局对象的操作和渲染。

### 设计态

设计态可以设置布局容器的属性，各布局类型可以设置的属性可以不同，例如网格布局可以设置行列数、各行各列宽度长度（支持定值和弹性）。

布局容器支持动画，但不建议使用，对于数据状态驱动的页面，布局级别的动画成本比较高。

设计器也提供对基础`cell`单元（里面放置组件）的操作: 设置位置、大小，组件是否撑满`cell`。

#### 嵌套布局的交互问题（?script）

一个布局对象在画布上仅可以操作第一层组件，组件内置的布局需要进入布局的画布才可以设置。

在特殊场景下，UI层的布局层级在渲染时可以合并。

例如：实体表单放到到实体表单页面中时，实体表单页外层有一个栅格布局，而实体表单组件内部也有一个布局。但是在设计时，将表头、表尾、主表、子表直接分散到实体表单页的布局上即可。

### 渲染态

从设计态导出保存的数据对象，是一个纯粹的布局数据 —— 剥离掉设计态状态相关的所有属性和方法。

在实现上，设计态和渲染态的代码实现也是两套，以避免代码上渲染态被设计态污染，引发棘手的性能问题。

所以在前期实现时，渲染时的数据将是纯粹的静态布局数据，不带有操作。

## 布局类型定义

### 命名

布局对象命名遵守 `Nl***`(Nl = Neo Layout) 的规则， `***` 需要反应你的布局功能，可以适当缩写.

例如：
 - `NlGrid`  —— 通用二维栅格布局，基于`css-grid`实现
 - `NlFlex`  —— 通用一维弹性布局，基于`css-flex`实现
 - `NlEntityPageGrid`
 - `NlEntityPageForm`
 - `NlEntityPageDetail`
 - `NlEntityPageFormOpportunity`
 -  ...

### 基本属性

```js
{
  type: `NlGrid`,
  name: `NlGrid`,
  // 未完成
  // ...
}
```

### 插槽（SLOT）的设计

服务于特定场景的布局类型，往往布局不可随意调整，但是布局上的一部分开放性会以插槽的方式暴露出去：仅在指定的位置可以插入或者替换组件。

插槽在布局引擎上以`cell`规则呈现，但插槽需要指定id.

### 布局实例定义

类似于`vue`组件模板的语法糖。

这里实现有两种方式，一种是通过注解，编译成目标结构；另外一种是直接写在目标结构。两者是开发时的区别，并不冲突，因此此处留白。

以下展示最终结构：

```js
{
  type: '',
  // cells是全集，初始不显示的可以设置visible:false。
  // cell可以是不定组件，通过一些api或者动态方法加载具体的组件
  cells: [{}, {}, {}],
  // 布局对象暴露支持调用的方法，设计器中可展示
  // 同名action会以洋葱模型构建
  // 各cell可以接受到，并响应 amis的 target语法
  actions: {
    changeState: function(state){
      this.state = state
    },
    // 刷新表格
    reloadNeoGrid: function(){
      //....
    },
    // 切换BI报表的展示
    toggleBiView: function() {
      // 通过切换cell的坐标位置实现
    }
    
  }
}
```

对于一个布局模板，它的cells和actions之类会直接固定，仅通过action可以修改。 组件开发出模板之后，通过`react.context`传递给实际的布局渲染组件，初始化为实际的布局对象。

所有布局模板和布局类型的实例，符合里氏替换原则。

对于内置布局的组件来说，布局模板就是它的store。

#### 布局上的公共属性


#### 布局内组件的通信方式

遵守的原则和react声明式方式一样，禁止同级组件之间互传实例，同级组件之间互相调用方法通过组件间接口：

```js
{
  type: "cmpA",
  // cmpA的click使用了cmpB.reload
  // 但并没有把cmpB传入组件A中，两个组件之间并没有关系
  onClick: ()=> {
    cmpB.reload()
  }
}
```

## 当前支持

### NLayoutGrid

完全自由的栅格布局，目前应用在实体例表页、实例表单的`content`中。

## TODO

现在系统中存在多份grid css的实现.

当前表单使用了`neo layout grid`布局

列表和详情页使用的都是原始的`grid-2d`, 所以要将这两个迁移。

## QA

### 面向专业开发者的开发体验




